# 密码学的几个问题：
--- ------------------------------------------------------------------
| 类型 | 说明 | 性质 | 方案 |
| ---- | ---- | ---- | ---- |
| 反窃听(加密)       |秘密泄露           |机密性		|对称、非对称加密   |
| 反篡改(摘要)       |信息被修改	    |完整性		|散列、摘要        |
| 反伪装(数字证书)     |伪装成发送者	    |认证		|数字证书、CA证书   |
| 反否认(数字签名)     |事后防止否认	    |不可否认性	|数字签名          |
| 反重放(一次性消息)    |消息被重复发送	|一次性		|一次性消息控制     |
--- ------------------------------------------------------------------
## 提出一种解决方式
--- ------------------------------------------------------------------
- 反窃听
	- 使用加密解决
	- 使用对称加密与非对称加密的混合加密方式实现
	- 这里以rsa(非对称加密)+aes(对称加密)方式举例
	- 加密方sender
		- 生成随机aes秘钥aes_key
		- 使用自己的rsa私钥sender_rsa_pri_key用rsa加密aes_key得到enc_aes_key
		- 使用aes_key秘钥用aes加密消息体msg得到enc_msg
		- 将加密后的秘钥enc_aes_key和消息体enc_msg发送给解密方recver
	- 解密方recver
		- 获取加密方的公钥sender_rsa_pub_key
		- 使用加密方公钥sender_rsa_pub_key用rsa解密enc_aes_key得到aes_key
		- 使用aes_key用aes解密消息体enc_msg得到msg
	- 因此，在此过程中
		- 双方，具有各自的非对称秘钥对
		- 双方，具有对方的公钥，自己保留自己的私钥
		- 双方，需要解密之前，都要获取对方的公钥
	- 在BS/CS模式下的实现
		- 服务端初始化自己的秘钥对，server_pub_key,server_pri_key
		- 等待客户端连接
		- 客户端初始化自己的秘钥对，client_pub_key,client_pri_key
		- 客户端携带自己的公钥client_pub_key请求得到服务端的公钥server_pub_key
		- 此过程之后，双方都具有自己的密钥对，以及对方的公钥
		- 此后的消息通信，均按照上面的流程进行即可
- 反篡改
	- 使用摘要解决
	- 这里以MD5(消息摘要)方式为例
	- 发送方sender
		- 按照指定的规则rule，对消息体msg重排sort得到sort_msg
		- 对重排后的消息sort_msg进行消息摘要hash
		- 将消息摘要hash作为send_hash和消息体msg发送给接受方
	- 接收方recver
		- 使用相同的规则rule对消息体msg进行重排sort得到sort_msg
		- 对重排后的消息sort_msg进行消息摘要hash
		- 将得到的消息摘要hash与接受到的send_hash进行比较
		- 比较结果一致，则没有被篡改，否则被篡改，消息应该丢弃
- 反伪装
	- 使用数字证书，由CA颁发
	- 弱化情况下可以与反否认进行概念交叉即可
- 反否认
	- 使用数字签名
	- 还是以rsa为例
	- 发送方sender
		- 使用自己的rsa私钥sender_rsa_pri_key用rsa加密对应的内容msg得到send_msg
	- 接受方
		- 使用发送方的公钥send_rsa_pub_key用rsa解密send_msg
		- 若解密成功，则说明消息确实是发送方发送，否则，消息不是发送方发送，应该丢弃
	- 此方式如果是使用了非对称方式进行消息加密的话，其实已经覆盖到了
- 反重放
	- 使用唯一序列号解决
	- 序列号需要保证一定时间限度内不重复
	- 一般防重放的最短时间限度应该大于15分钟
	- 因为对于恶意重放请求的情况，都是在请求的之后的一段接近时间内进行的
--- ------------------------------------------------------------------
## 构建一个统一的体系
--- ------------------------------------------------------------------
- 定义一个秘钥结构
```c
{
	mine_pub_key, // 自身公钥
	mine_pri_key, // 自身私钥
	
	other_pub_key, // 其他人的公钥
}
```
- 定义一个消息头结构
```c
{
	random_key,	// 随机生成的对称秘钥
	signature, // 消息体签名
	nonce	// 一次性消息头
}
```
- 定义一个消息
```c
{
	msg // 消息内容
}
```
- 一个通信消息
```c
{
    random_key,	// 随机生成的对称秘钥
    signature, // 消息体签名
    nonce	// 一次性消息头
    msg // 消息内容
}
```
--- ------------------------------------------------------------------
## 综合构建一个较为完善的安全体系
--- ------------------------------------------------------------------
- 初始化
	- 生成自身的非对称秘钥对mine_pub_key,mine_pri_key
	- 携带自身公钥mine_pub_key请求对方公钥other_pub_key
- 发送消息body
	- 生成随机秘钥key=random.randomKey()【反窃听，防止固定秘钥被解密】
	- 由随机秘钥key使用对方公钥other_pub_key用rsa生成消息头random_key=rsa.encryptPublicKey(key)【消息体反窃听】
	- 生成一次性消息头nonce=guid.nextGuid()【反重放】
	- 使用对称加密aes用key加密body得到msg=aes.encrypt(body)【反窃听】
	- 计算消息签名send_sign=md5(msg+nonce+random_key)【反篡改】
	- 计算消息签名,用自身私钥mine_pri_key加密,带上数字签名属性，signature=rsa.encrypt(send_sign)【反否认】
	- 发送消息：msg,signature,nonce,random_key
- 接受消息
	- 解密发送过来的signature，用对方公钥other_pub_key解密，得到send_sign=rsa.decrypt(signature)【反否认，验证数字签名】
	- 判断是否解密send_sign是否成功
		- 如果解密失败，则数字签名验证失败，消息不合法
	- 如果成功则继续
	- 计算收到消息的签名recv_sign=md5(msg+nonce+random_key)【反篡改，验证消息散列】
	- 比较recv_sign==send_sign
		- 如果不相等，则丢弃消息，消息不合法
	- 如果相等则继续
	- 判断nonce是否已经在nonce池中【反重放，验证一次性消息】
		- 如果已经在，则是重放请求，丢弃消息
	- 如果不存在则继续
	- 使用rsa用自身的私钥mine_pri_key解密random_key得到key=rsa.decryptPrivateKey(random_key)【反窃听】
	- 使用对称加密aes用key解密消息msg得到body=aes.decrypt(msg)【反窃听】
	- 处理消息体body的内容
	- 处理完毕之后，按照发送消息顺序，将响应消息返回
- 缺陷：
	- 反伪装，机制缺少，没办法防止伪装的请求
	- 解决方案：
		- 引入CA数字证书
		- 一般来说，CA证书是归属服务器端所有
		- 客户端下载网站的数字证书
		- 使用数字证书颁发CA机构的公钥验证数字证书
		- 验证通过，则消息能够确认【反伪装】

